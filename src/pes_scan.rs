//! PES (Potential Energy Surface) scanning functionality.
//!
//! This module implements comprehensive PES scanning capabilities following
//! the Python MECP.py implementation exactly. It supports:
//!
//! - 1D and 2D potential energy surface scans
//! - Automatic scan grid generation
//! - Constrained MECP optimization at each scan point
//! - Result analysis and visualization data generation
//! - Comprehensive reporting and convergence tracking

use crate::geometry::Geometry;

/// Represents the result of a single PES scan point.
#[derive(Debug, Clone)]
pub struct ScanPointResult {
    /// First scan coordinate value
    pub coord1: f64,
    /// Second scan coordinate value (may be dummy for 1D scans)
    pub coord2: f64,
    /// Energy of state A at this point
    pub energy_a: f64,
    /// Energy of state B at this point
    pub energy_b: f64,
    /// Energy difference (E_A - E_B)
    pub energy_diff: f64,
    /// Whether the optimization converged at this point
    pub converged: bool,
    /// Number of optimization steps taken
    pub num_steps: usize,
    /// Final geometry at this scan point
    pub geometry: Geometry,
}

/// Analyzes and collects PES scan results following Python MECP.py logic.
///
/// This function implements scan result analysis capabilities including:
/// - Energy surface data collection
/// - Convergence tracking for each scan point
/// - Summary report generation
/// - Data formatting for plotting
///
/// # Arguments
///
/// * `scan_results` - Collection of scan point results
/// * `output_file` - Path for the analysis output file
///
/// # Returns
///
/// Returns `Ok(())` on successful analysis completion.
pub fn analyze_scan_results(
    scan_results: &[ScanPointResult],
    output_file: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("\n****Analyzing PES Scan Results****");

    // Generate scan summary report
    generate_scan_summary(scan_results, output_file)?;

    // Generate energy surface data for plotting
    generate_energy_surface_data(scan_results, &format!("{}.dat", output_file))?;

    // Generate convergence tracking report
    generate_convergence_report(scan_results, &format!("{}_convergence.txt", output_file))?;

    println!("Scan analysis completed. Results saved to: {}", output_file);
    Ok(())
}

/// Generates a comprehensive scan summary report.
///
/// This function creates a detailed summary of the PES scan results,
/// including statistics, energy ranges, and convergence information.
///
/// # Arguments
///
/// * `scan_results` - Collection of scan point results
/// * `output_file` - Path for the summary report
///
/// # Returns
///
/// Returns `Ok(())` on successful report generation.
fn generate_scan_summary(
    scan_results: &[ScanPointResult],
    output_file: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut summary = String::new();

    summary.push_str("# PES Scan Summary Report\n");
    summary.push_str(&format!("# Generated by OpenMECP\n\n"));

    // Basic statistics
    summary.push_str(&format!("Total scan points: {}\n", scan_results.len()));
    
    let converged_count = scan_results.iter().filter(|r| r.converged).count();
    summary.push_str(&format!("Converged points: {}\n", converged_count));
    summary.push_str(&format!("Convergence rate: {:.1}%\n\n", 
        100.0 * converged_count as f64 / scan_results.len() as f64));

    // Energy statistics (only for converged points)
    let converged_results: Vec<_> = scan_results.iter().filter(|r| r.converged).collect();
    if !converged_results.is_empty() {
        let energies_a: Vec<f64> = converged_results.iter().map(|r| r.energy_a).collect();
        let energies_b: Vec<f64> = converged_results.iter().map(|r| r.energy_b).collect();
        let energy_diffs: Vec<f64> = converged_results.iter().map(|r| r.energy_diff).collect();

        let min_a = energies_a.iter().fold(f64::INFINITY, |a, &b| a.min(b));
        let max_a = energies_a.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));
        let min_b = energies_b.iter().fold(f64::INFINITY, |a, &b| a.min(b));
        let max_b = energies_b.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));
        let min_diff = energy_diffs.iter().fold(f64::INFINITY, |a, &b| a.min(b));
        let max_diff = energy_diffs.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b));

        summary.push_str("Energy Statistics (Hartree, converged points only):\n");
        summary.push_str(&format!("State A: {:.6} to {:.6}\n", min_a, max_a));
        summary.push_str(&format!("State B: {:.6} to {:.6}\n", min_b, max_b));
        summary.push_str(&format!("Energy Difference: {:.6} to {:.6}\n\n", min_diff, max_diff));

        // Find minimum energy difference point
        if let Some(min_diff_result) = converged_results.iter().min_by(|a, b| 
            a.energy_diff.abs().partial_cmp(&b.energy_diff.abs()).unwrap()) {
            summary.push_str("Minimum |Î”E| Point:\n");
            summary.push_str(&format!("Coordinates: ({:.4}, {:.4})\n", 
                min_diff_result.coord1, min_diff_result.coord2));
            summary.push_str(&format!("Energy difference: {:.6} Hartree ({:.3} eV)\n\n", 
                min_diff_result.energy_diff, min_diff_result.energy_diff * 27.211386));
        }
    }

    // Detailed point-by-point results
    summary.push_str("Detailed Results:\n");
    summary.push_str("Coord1    Coord2    Energy_A      Energy_B      Delta_E       Conv  Steps\n");
    summary.push_str("------------------------------------------------------------------------\n");

    for result in scan_results {
        if result.converged {
            summary.push_str(&format!(
                "{:8.4} {:8.4} {:12.6} {:12.6} {:12.6} {:4} {:5}\n",
                result.coord1,
                result.coord2,
                result.energy_a,
                result.energy_b,
                result.energy_diff,
                "Yes",
                result.num_steps
            ));
        } else {
            summary.push_str(&format!(
                "{:8.4} {:8.4} {:>12} {:>12} {:>12} {:4} {:5}\n",
                result.coord1,
                result.coord2,
                "FAILED",
                "FAILED",
                "FAILED",
                "No",
                result.num_steps
            ));
        }
    }

    std::fs::write(output_file, summary)?;
    println!("Scan summary saved to: {}", output_file);
    Ok(())
}

/// Generates energy surface data suitable for plotting.
///
/// This function creates data files in formats suitable for plotting programs
/// like gnuplot, matplotlib, or other visualization tools.
///
/// # Arguments
///
/// * `scan_results` - Collection of scan point results
/// * `output_file` - Path for the plotting data file
///
/// # Returns
///
/// Returns `Ok(())` on successful data file generation.
fn generate_energy_surface_data(
    scan_results: &[ScanPointResult],
    output_file: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut data = String::new();

    // Header for plotting data
    data.push_str("# PES Scan Energy Surface Data\n");
    data.push_str("# Columns: Coord1 Coord2 Energy_A Energy_B Energy_Diff Converged\n");
    data.push_str("# Suitable for gnuplot splot or matplotlib\n");
    data.push_str("# Non-converged points have energy values set to NaN\n\n");

    for result in scan_results {
        if result.converged {
            data.push_str(&format!(
                "{:.6} {:.6} {:.8} {:.8} {:.8} 1\n",
                result.coord1,
                result.coord2,
                result.energy_a,
                result.energy_b,
                result.energy_diff
            ));
        } else {
            data.push_str(&format!(
                "{:.6} {:.6} NaN NaN NaN 0\n",
                result.coord1,
                result.coord2
            ));
        }
    }

    std::fs::write(output_file, data)?;
    println!("Energy surface data saved to: {}", output_file);
    Ok(())
}

/// Generates a convergence tracking report.
///
/// This function analyzes the convergence behavior across the scan,
/// identifying problematic regions and optimization statistics.
///
/// # Arguments
///
/// * `scan_results` - Collection of scan point results
/// * `output_file` - Path for the convergence report
///
/// # Returns
///
/// Returns `Ok(())` on successful report generation.
fn generate_convergence_report(
    scan_results: &[ScanPointResult],
    output_file: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut report = String::new();

    report.push_str("# PES Scan Convergence Analysis\n\n");

    // Convergence statistics
    let total_points = scan_results.len();
    let converged_points = scan_results.iter().filter(|r| r.converged).count();
    let failed_points = total_points - converged_points;

    report.push_str(&format!("Total scan points: {}\n", total_points));
    report.push_str(&format!("Successfully converged: {}\n", converged_points));
    report.push_str(&format!("Failed to converge: {}\n", failed_points));
    report.push_str(&format!("Success rate: {:.1}%\n\n", 
        100.0 * converged_points as f64 / total_points as f64));

    // Step count statistics (only for converged points)
    let converged_results: Vec<_> = scan_results.iter().filter(|r| r.converged).collect();
    if !converged_results.is_empty() {
        let step_counts: Vec<usize> = converged_results.iter().map(|r| r.num_steps).collect();
        let avg_steps = step_counts.iter().sum::<usize>() as f64 / step_counts.len() as f64;
        let min_steps = *step_counts.iter().min().unwrap_or(&0);
        let max_steps = *step_counts.iter().max().unwrap_or(&0);

        report.push_str("Optimization Steps Statistics (converged points only):\n");
        report.push_str(&format!("Average steps: {:.1}\n", avg_steps));
        report.push_str(&format!("Minimum steps: {}\n", min_steps));
        report.push_str(&format!("Maximum steps: {}\n\n", max_steps));
    }

    // List problematic points
    report.push_str("Non-converged Points:\n");
    if failed_points > 0 {
        report.push_str("Coord1    Coord2    Steps\n");
        report.push_str("------------------------\n");
        for result in scan_results.iter().filter(|r| !r.converged) {
            report.push_str(&format!(
                "{:8.4} {:8.4} {:5}\n",
                result.coord1,
                result.coord2,
                result.num_steps
            ));
        }
    } else {
        report.push_str("All scan points converged successfully!\n");
    }

    std::fs::write(output_file, report)?;
    println!("Convergence report saved to: {}", output_file);
    Ok(())
}